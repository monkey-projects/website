{:title "Artifacts"
 :related [["caches" "Caches"]]}

Job artifacts serve two purposes:

 - To publish generated files to the outside world.
 - To pass files between two jobs within the same build.

And jobs can do two things with artifacts: **save them** or **restore them**.

## Saving artifacts

Jobs that create artifacts in order for other jobs to use them, or to make them
available for download, need to explicitly tell *MonkeyCI* where to find the
artifact files in question, and give them an id.  This id will be used to refer
to them in other jobs.  This is done using the `save-artifacts` function.  For
example:

```clojure
(def create-file
  (-> (action-job
        "create-file-job"
	(fn [ctx]
	  (spit "test.txt" "This is an artifact file")))
      (save-artifacts (artifact "some-id" "test.txt"))))
```

In this example we use the [Clojure standard spit function](https://clojuredocs.org/clojure.core/spit)
to write a string to a file.  The `artifact` function is available to declare an
artifact, with an id and a location.  The location is relative to the job working
directory, which is the checkout directory by default.

## Using artifacts

Jobs that want to use an artifact that has been generated by another job, must
indicate that to *MonkeyCI*.  Both the id of the artifact, and where to restore
it has to be specified.  For this, the `restore-artifacts` function is available.

Building further on the previous example, we could write another job that uses
the saved artifact like so:

```clojure
(def use-file
  (-> (action-job
        "use-file-job"
	(fn [ctx]
	  (println "The artifact contents is:" (slurp "test.txt"))))
      (restore-artifacts (artifact "some-id" "test.txt"))
      (depends-on "create-file-job"))
```

We use the counterpart of `spit`, called `slurp` to read the file contents here.
Of course, this is a contrived example, but it illustrates the point.  Also note
the explicit dependency declaration, more on that below.

## Dependencies

Note that **artifacts do not imply dependency**.  You still have to specify the
job interdependencies explicitly.  *MonkeyCI* will not warn you when a job wants
to restore an artifact that is not being saved in the dependency chain (although
we may add that as a feature later on).  The artifact will simply not be available,
and the job will probably fail.

So for *MonkeyCI* it's perfectly acceptable that an artifact is not available,
it's up to the job itself to handle that situation.